import java.util.ArrayList;import java.util.List;public final class LinkedQueue {	// references the node at the front of queue	private Node firstNode;	// references node at the back of queue	private Node lastNode;  	  	// zero-parameter constructor	public LinkedQueue() {		firstNode = null;		lastNode = null;	}		// add an element to the queue	public void enQueue(ArrayList newEntry) {		// create a new node, store the value in data field,		// and store null in the next field		Node newNode = new Node(newEntry, null);				// if the queue is empty, then this is the first 		// element in the queue		if (isEmpty())			// first node is the new node			firstNode = newNode;		else			// otherwise, the newly created node becomes the last node			// by setting the next field value of last node to the new 			// node (reference)			lastNode.setNextNode(newNode);		// in both cases (i.e., empty queue and non-empty queue),		// last node is always the new node		lastNode = newNode;	}	// retrieve the value of the first element in the queue	public ArrayList getFront() {		// if queue is empty, throw empty queue exception		if (isEmpty())			throw new EmptyQueueException();		else // otherwise, return the value of the first element			return firstNode.getData();	}	// remove and return the first element in the queue	public ArrayList deQueue() {		// retrieve the element which is in the front of the queue		// note that the element is not removed, only retrieved		ArrayList nodeValue = getFront();		// we would not get here if the queue were to be empty		// as getFront() would have thrown an exception, and control		// transferred to exception handler		// therefore, first node should not be null (as queue must 		// have at least one element)		assert firstNode != null;		// we have already retrieved the data in the first node through		// getFront(), therefore, set its data field value to null		firstNode.setData(null);		// make the node that follows the first node as the		// new first node		firstNode = firstNode.getNextNode();            	// this case corresponds to removing an element from      	// the queue, which had only one element. therefore,      	// the queue is empty now. set last node to null		if (firstNode == null)			lastNode = null;				// 		return nodeValue;	} 	// remove and return the nth element in the queue	// one-based counting	public ArrayList nthElement(int n) {		// System.out.println("\nValue of n is: " + n);		// n should be greater than zero		if (n <= 0){			System.out.println(n + " should be greater than or equal to 0");			return null;		}		// if the nth element is greater than the number		// of elements in the queue, return null and exit		if (n > size()){			System.out.println(n + " element is greater than the queue size " + size());			return null;		}		// queue has only one element and the request is for this element		if ((firstNode.getNextNode() == null) && (n==1)) {			return firstNode.getData();		}		else {			// for traversing through the queue			int index = 1;			// references an arbitrary element in the queue			Node tempNode = firstNode;			// traverse the queue to locate the nth element			while (tempNode != null && index < n){				tempNode = tempNode.getNextNode();				index++;			}			return tempNode.getData();		}	}	// returns the queue size	public int size(){		// queue is empty		if (firstNode == null){			return 0;		}		// queue has only one element		else if (firstNode.getNextNode() == null){			return 1;		}		// queue has more than one element		else {			// for traversing through the queue			int index = 1;			// references an arbitrary element in the queue			Node tempNode = firstNode;			while (tempNode.getNextNode() != null){				tempNode = tempNode.getNextNode();				index++;			}			return index;		}	}			// for queue to be empty, both the first node and the	// last node must be null	public boolean isEmpty() {		return (firstNode == null) && (lastNode == null);	}		// clearing a queue is essentially setting the first	// node and last node values to null	public void clear() {		firstNode = null;			lastNode = null;	}	// internal class, private to LinkedQueue class	private class Node {		// data field of Node		private ArrayList data;		// reference to the node that follows (this node)		private Node next; 		// two-parameter constructor		// @param data is the value to be stored in the new node		// @param next is the reference to an existing node, which 		// will follow the node that is being created		public Node(ArrayList data, Node next) {			this.data = data;			this.next = next;			}		// like a normal get method, returns the data field 		// of the node under consideration		public ArrayList getData() {			return data;		}		// change the data field value of the node under consideration		public void setData(ArrayList newData) {			data = newData;		}		// given a node, returns the reference to the node		// which follows the given node		public Node getNextNode() {			return next;		}		// given a node y (i.e., nextNode), make y		// as the node that follows the node under consideration		public void setNextNode(Node nextNode) {			next = nextNode;		}	}	} 